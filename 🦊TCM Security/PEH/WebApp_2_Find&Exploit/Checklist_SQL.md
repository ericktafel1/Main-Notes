#SQL 

# Overview

- [ ]   What is the technology stack you're attacking?
    - [ ]   What application/framework is being used
    - [ ]   What backend DB is being used
- [ ]   Verify injection points
    - [ ]   HTTP headers (e.g. cookies, etc)
    - [ ]   Out-of-band (e.g. data retrieved from a third party)
- [ ]   Test ' and "
    - [ ]   Can you trigger an error?
    - [ ]   Can you trigger a different response?
- [ ]   Test for login bypass `' and 1=1-- -` etc
- [ ]   Test for blind SQLi
    - [ ]   Test for conditional responses
    - [ ]   Test for conditional errors
- [ ]   Test for out-of-band interactions
- [ ]   Is there a blocklist?
    - [ ]   Can you bypass the blocklist?
- [ ]   Test for second-order SQLi
---
# Detection

The goal with many of these tests is to invoke some behavior change in the application. Be sure to closely monitor for:
-   Content-Length header changes
-   Changes in the data returned
-   Second-order (i.e. you inject somewhere, but another interaction is required to trigger the payload)

Test cases:
- [ ]   Test with single and double quotes
- [ ]   Test with comments or terminators to mask the rest of the query
- [ ]   Test with other special characters that can manipulate SQL statements
- [ ]   Test with boolean conditions `and 1=1` and `and 1=2` (closely monitor the application response, in particular the Content-Length header)
- [ ]   Test with functions that cause time delays
    - [ ]   MS SQL Server `WAITFOR DELAY '0:0:05'`
    - [ ]   Oracle `dbms_pipe.receive_message(('x'),5)`
- [ ]   Test with out-of-band (OOB) or out-of-band application security testing (OAST) techniques
- [ ]   Test for `UNION` keyword
    - [ ]   `SELECT username,password FROM users UNION SELECT null,null`
    - [ ]   Test for the number of columns using `null,null` or `ORDER BY 1` , `ORDER BY 2`
    - [ ]   Test the data types with `'a',1` etc
- [ ]   Test with different encoding techniques
- [ ]   Test evasion techniques
    - [ ]   Test with encoded payloads
    - [ ]   Test with builting functions
    - [ ]   Test ways to bypass commonly filtered characters
        - [ ]   E.g. replacing space with `/**/`

---
# Blind
- [ ] Identify potential vulnerable points:
    - [ ] URL parameters
    - [ ] Form fields
    - [ ] HTTP headers (e.g. cookies, user-agent)
    - [ ] Hidden fields
- [ ] Test for true/false conditions:
    - [ ] Can you get a "true" condition? E.g., `' AND 1=1-- -`
    - [ ] Can you get a "false" condition? E.g., `' AND 1=2-- -`
- [ ] Time-based Blind SQLi:
    - [ ] Introduce artificial delays using functions like `SLEEP()` or `BENCHMARK()`
    - [ ] Measure response times
- [ ] Error-based Blind SQLi:
    - [ ] Test a divide by zero payload
    - [ ] Can we trigger an error message?
        - [ ] Can we use `CAST()` to trigger an error and view the data?
- [ ] Content-based Blind SQLi:
    - [ ] Check for changes in page content based on payloads
- [ ] Out-of-band (OAST):
    - [ ] Can we trigger a DNS query?
    - [ ] Can we append some data to the subdomain of the URL to exfiltrate information?
- [ ] Binary search based extraction:
    - [ ] Exploit faster by dividing data and querying
- [ ] Backend specifics:
    - [ ] Are you dealing with MySQL, MSSQL, Oracle, PostgreSQL, SQLite?
    - [ ] Adjust your payloads accordingly
- [ ] Test with automated tools:
    - [ ] SQLmap with `--technique=B` flag
- [ ] Encoding and obfuscation:
    - [ ] Test with URL encoding, hex encoding, or other methods to bypass filters
- [ ] Bypassing filters:
    - [ ] Use comments, spaces, or alternative syntax
- [ ] Exploitation:
    - [ ] Extract database version, e.g., `AND (SELECT SUBSTRING(version(),1,1))='5'`
    - [ ] Fetch data character by character
    - [ ] Extract data from information_schema

---
